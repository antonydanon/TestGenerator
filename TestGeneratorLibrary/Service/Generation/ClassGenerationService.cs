using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestGeneratorLibrary.Service.Generation
{
    public class ClassGenerationService
    {
        public ClassDeclarationSyntax GenerateTestsClass(ClassDeclarationSyntax classDeclaration)
        {
            Dictionary<string, int> methodsCounts = GenerateMethodsCounts(classDeclaration);
            List<MemberDeclarationSyntax> testMethods = GenerateTestMethods(methodsCounts);
            
            var classDecl = ClassDeclaration(classDeclaration.Identifier.Text + "Tests")
                .AddModifiers(Token(SyntaxKind.PublicKeyword))
                .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testMethods))
                .WithAttributeLists(
                    SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestFixture"))))));
            return classDecl;
        }
        
        private Dictionary<string, int> GenerateMethodsCounts(ClassDeclarationSyntax classDeclaration)
        {
            List<MethodDeclarationSyntax> methods = classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .Where(method => method.Modifiers.Any(token => token.Kind() == SyntaxKind.PublicKeyword)).ToList();
            Dictionary<string, int> methodsCounts = new();

            foreach (var method in methods)
            {
                if (methodsCounts.TryGetValue(method.Identifier.Text, out var methodCount))
                    methodsCounts[method.Identifier.Text] = ++methodCount;
                else
                    methodsCounts.Add(method.Identifier.Text, 1);
            }
            
            return methodsCounts;
        }

        private List<MemberDeclarationSyntax> GenerateTestMethods(Dictionary<string, int> methods)
        {
            List<MemberDeclarationSyntax> testMethods = new List<MemberDeclarationSyntax>();
            StatementSyntax methodBody = GenerateMethodBody();
            foreach (var method in methods)
            {
                if (method.Value == 1)
                {
                    string methodName = method.Key + "Test";
                    testMethods.Add(GenerateTestMethod(methodName, methodBody));    
                }
                else
                {
                    for (int overloadedMethodNumber = 1; overloadedMethodNumber <= method.Value; overloadedMethodNumber++)
                    {
                        string methodName = method.Key + overloadedMethodNumber + "Test";
                        testMethods.Add(GenerateTestMethod(methodName, methodBody));
                    }
                }
            }
            return testMethods;
        }
        
        private StatementSyntax GenerateMethodBody()
        {
            return ExpressionStatement(
                InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName("Assert"), IdentifierName("Fail")))
                    .WithArgumentList(ArgumentList(SingletonSeparatedList(
                        Argument(LiteralExpression(SyntaxKind.StringLiteralExpression,
                            Literal("autogenerated")))))));
        }

        private MethodDeclarationSyntax GenerateTestMethod(string methodName, StatementSyntax methodBody)
        {
            return MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier(methodName))
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithAttributeLists(
                    SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("Test"))))))
                .WithBody(Block(methodBody));
        }
    }
}